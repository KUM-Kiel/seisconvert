\documentclass[DIV=10]{scrartcl}
\usepackage{amssymb}
\usepackage[fleqn]{amsmath}
\usepackage{mathspec}
\usepackage{xltxtra}
\usepackage{enumerate}
\usepackage{tikz}
\usepackage{ragged2e}
\usepackage{polyglossia}
\usepackage{microtype}
\setdefaultlanguage{english}

%\setromanfont{Linux Libertine O}
%\setmathfont(Digits,Latin){Linux Libertine O}

\addtokomafont{disposition}{\rmfamily}
\newcommand{\R}{\mathbb{R}}
\newcommand{\C}{\mathbb{C}}
\newcommand{\N}{\mathbb{N}}
\newcommand{\qed}{\hfill\(\Box\)\hspace{-10pt}\strut}

\makeatletter
\let\TagsLeftOn\tagsleft@true
\let\TagsLeftOff\tagsleft@false
\makeatother

%\pagestyle{myheadings}
%\markright{\textup{The KUM-Y File Format \hfill September 2014}}

\newcommand{\x}[1]{\textbackslash{}x#1}

%\setlength{\skip\footins}{15pt plus 15pt minus 0pt}
%\setlength{\footnotesep}{10pt}
%\renewcommand{\footnoterule}{%
%  \kern -6pt
%  \noindent \rule[3pt]{30pt}{1.5pt}
%  \kern 4.5pt
%}

%\makeatletter%
%\long\def\@makefntext#1{%
%  \noindent\RaggedRight \textrm{\textbf{\@thefnmark} #1}}%
%\makeatother

\DeclareTextFontCommand{\textref}{\rmfamily}

\renewenvironment{quote}
{\list{}{
  \setlength{\rightmargin}{0cm}
  \setlength{\leftmargin}{0.75cm}}%
\item\relax\ignorespaces}
{\unskip\unskip\endlist}

\newenvironment{openingquote}
{\list{}{
  \setlength{\rightmargin}{0cm}
  \setlength{\leftmargin}{5cm}}%
\item\relax\fontsize{8pt}{12pt}\selectfont\ignorespaces}
{\unskip\unskip\endlist}

\newenvironment{literature}
{\list{}{
  \setlength{\leftmargin}{10pt}
  \setlength{\labelwidth}{0pt}
  \setlength{\labelsep}{0pt}
  \setlength{\itemindent}{-10pt}
  \setlength{\itemsep}{-2pt}
}\RaggedRight}
{\endlist}

\newcommand\litref[1]{\textref{[#1]}}
\newenvironment{refliterature}
{\list{}{
  \setlength{\leftmargin}{45pt}
  \setlength{\labelwidth}{45pt}
  \setlength{\labelsep}{0pt}
  \setlength{\itemindent}{0pt}
  \setlength{\itemsep}{-2pt}
  \let\makelabel\litref
}\RaggedRight}
{\endlist}

\begin{document}

\strut

\vspace{1cm}

\centerline{\huge \textbf{The KUM-Y File Format%
\footnote{\raggedright Date of this document: 2014-11-03.
Permanent ID of this document: bd59ae8cc054eee9b8e2c779ba1b6ab9.}}}

\vspace{1cm}

\section{Introduction}

The KUM-Y file format is a format for efficiently storing, transmitting and processing seismic data, generated by various kinds of recorders.

There are already formats in use for this purpose, most notably SEG-Y and SEED, but these formats are subject to several disadvantages, which the format presented in this paper tries to address.

A software package to transform data between different formats is provided. 

\section{Conventions}

A KUM-Y file can be seen as a finite sequence of 8 bit bytes.
Handling and storage of this byte stream is up to the application and the operating system.
This could be a file on a hard disc or SD card, but a TCP stream would be perfectly acceptable as well.

Characters may be depicted by their hexadecimal representation.
So the string represented by <48 65 6c 6c 6f 20 57 6f 72 6c 64 21> is the same as “Hello World!”.

\subsection{Variable Length Integers}
\label{varint}

Numbers in the KUM-Y format are encoded using a variable length encoding. The encoding is simular to little endian format.
This has the advantage of reasonable compression ratios for small, highly correlated signals, especially when used with a low order linear prediction filter.

A variable length integer consists of at least one byte.
Depending on the first bits of each byte, the meaning of the byte’s content varies.

\begin{itemize}
\item “0”: The next seven bits are less significant bits of an integer.
The next byte continues the integer.
\item “10”: The next six bits are the most significant bits of an integer.
This is the last byte of an integer.
If this byte is not preceeded by a byte starting with “0”, it is a complete integer on it’s own.
\item “11”: A byte starting as such is not part of an integer.
It is instead reserved as starting byte for special control frames.
The next six bits determine the type of the control frame.
See section \ref{controlframes} for a detailed description.
\end{itemize}

The first byte includes after the “0” the seven least significant bits of the number, the next byte includes the next seven bits and so on.
The last bit then contains the most significant six bits (after the “10”).
If the number fits into six bits, i.\,e.\ it is between \(-32\) and \(31\) inclusive, then it is encoded in just one byte with the leading “10” bits.
The number is interpreted as a two’s complement integer.
Note, that the third bit of the last byte always encodes the sign.

Conforming applications should always use the shortest possible representaton for a variable length integer.
So it is highly discouraged to encode e.\,g.\ 27 as <9b 00> instead of <1b>.

The following algorithm can be used to write an arbitrary integer \(n\) in variable length encoding.

\begin{verbatim}
while (n < -32 || 31 < n) {
  putchar(n & 0x7f);
  n >>= 7;
}
putchar(n & 0x3f | 0x80);
\end{verbatim}

\subsection{Strings}

Strings are sequences of 8 bit bytes.
Any characters are acceptable, though for maximum portability the content should be restricted to UTF-8 encoded text.

Strings may be of arbitrary length as they are always embedded with their byte length aside.

\subsection{Times and Durations}

Times and durations are encoded as TAIN labels.
A TAIN label consists of two integers \(s\) and \(n\).
\(n\) is limited to between 0 and 999,999,999 inclusive.

The TAIN label then encodes the duration
\[
  d = \left(s + n\cdot10^{-9}\right) \cdot 1\text{\,s}.
\]
If the label represents an \emph{absolute} time rather than a duration, then it is calculated as
\[
  t = t_{1970} + d
\]
where \(t_{1970}\) is the moment that began 1970\,TAI\footnote{Temps Atomique International}.
In other words \(d\) encodes the number of seconds since \mbox{1970-01-01} \mbox{00:00:00} TAI.

\clearpage
\section{The Binary Markup Language}

The KUM-Y file contains seismic data as well as text information, timing information, position information and other helpful data. To clearly separate different types of information we use defined data types as described below.

The Binary Markup Language or short BML is used for storing arbitrary structured data.
It supports the following data types.

\begin{itemize}
\item \textbf{Integer}\\
An integer is encoded as the byte <f0> followed by a variable length integer encoding the value.

\item \textbf{String}\\
A string is encoded as the byte <f1> followed by a variable length integer encoding the number of bytes of the string followed by the actual string bytes.

\item \textbf{Array}\\
An array holds arbitrary values in an ordered fashion.
It is encoded as the byte <f2> followed by a variable length integer encoding the number of elements in the array followed by the elements itself.

\item \textbf{Table}\\
A table holds arbitrary key value pairs.
It is encoded as the byte <f3> followed by a variable length integer encoding the number of key value pairs in the table followed by the pairs itself.

\item \textbf{Time}\\
A time value holds a TAIN label.
It is encoded as the byte <f4> followed by a variable length integer encoding the seconds followed by a variable length integer encoding the nanoseconds.

\item \textbf{Float}\\
This value holds a floating point number.
It is encoded as two variable legth integers \(a\) and \(b\).
They encode the value \(a\cdot10^b\).
Note, that this is a base ten representation, not base two.
\end{itemize}

\clearpage

\section{Structure of a KUM-Y File}

The general structure of a KUM-Y file is depicted in figure \ref{structure}.

\begin{figure}[ht]
\centerline{\begin{tikzpicture}
\draw
  (0, 0) rectangle +(\textwidth/6, -1.2) +(\textwidth/12, -0.6) node[align=center] {Magic\\Number}
  ++(\textwidth/6, 0) rectangle +(\textwidth/6, -1.2) +(\textwidth/12, -0.6) node[align=center] {Textual\\Metadata}
  ++(\textwidth/6, 0) rectangle +(\textwidth/6, -1.2) +(\textwidth/12, -0.6) node[align=center] {Binary\\Header}
  ++(\textwidth/6, 0) rectangle +(\textwidth/6, -1.2) +(\textwidth/12, -0.6) node {Data}
  ++(\textwidth/6, 0) rectangle +(\textwidth/6, -1.2) +(\textwidth/12, -0.6) node {\(\dotsm\)}
  ++(\textwidth/6, 0) rectangle +(\textwidth/6, -1.2) +(\textwidth/12, -0.6) node {Data};
\end{tikzpicture}}
\caption{Structure of a KUM-Y File}
\label{structure}
\end{figure}

\subsection{Magic Number}

Every KUM-Y file must start with a sequence of exactly eight bytes, that identifies the file as KUM-Y format.
The sequence is <4b 55 4d 2d 59 20 31 0a> (i.\,e.\ “KUM-Y 1” followed by a line feed) for version 1 of the format.

The magic number may change in future revisions of the format to allow easy detection of the format version.

\subsection{Textual Metadata}

The magic number is followed by human readable information associated with the file.
This text metadata is a string of arbitrary length, encoded as the byte length of the string in decimal with ascii digits, followed by <0a>, followed by the string data, followed by <0a 04>.

The length must be encoded in the shortest possible manner, so leading zeros are disallowed except for the empty string, which is encoded as <30 0a 0a 04>.

With this definition the file can be easily opened with any text editor and the textual information can be inspected.

Using the Bytes <0a 04> (line feed \& end of transmission) ensures that most of the common text editors do not display the following binary data.

It is recommended to use a multiple of 3200 bytes for the length and format the metadata according to the SEG-Y text header (see \litref{Segy02}).
This ensures a convinient and well known data layout for geophysicists.

However, this metadata is of solely informative interest.
It shall not be interpreted in any way by processing applications.

\clearpage

\subsection{Binary Header}

The binary header encodes all the information, that is necessary to read the time series in the file.

The header is a BML table with integer keys.
Some entries are required, while others are optional.

The header fields are in particular (denoted as “Key: Value type – Description”):
\begin{itemize}
  \item 1: String – The recording ID. (Required)\\
  This might be an arbitrary recorder identifier (e.\,g.\ the serial number) together with an increasing number or a human readable form of the start time.
  This should be customiseable by the user.
  \item 2: String – Experiment name. (Optional)
  \item 3: String – Station name. (Optional)
  \item 4: String – Station comment. (Optional)
  \item 5: String – Client. (Optional)\\
  This field holds the name of the university or commercial company.
  \item 6: String – The deployment operator. (Optional)\\
  This field contains the person responsible for the starting of the recording.
  \item 7: String – The recovery operator. (Optional)\\
  This field contains the person responsible for the ending of the recording.

  \item 10: Array – Position trace. (Optional)\\
  This array contains a trace of the recording positions.
  Each entry is a table with the following keys:
  \begin{itemize}
    \item 1: Time – The time of this measurement. (Required)\\
    This is an absolute time.
    \item 2: Float – Latitude. (Optional)\\
    This value encodes the geographical latitude in degrees.
    North is positive, the equator is zero.
    \item 3: Float – Longitude. (Optional)\\
    This value encodes the geographical longitude in degrees.
    East is positive, the meridian passing through Greenwich is zero.
    \item 4: Float – The height above sea level. (Optional)\\
    This value encodes the height above sea level in meters.
    If the recorder is submerged, this number is negative.
    \item 5: Float – \(z\) rotation. (Optional)\\
    Rotation is noted in Euler \(z\) - \(x\)’ - \(z\)” convention. 
    Starting from a coordinate system where \(x\) is east, \(y\) is north and \(z\) is up, this value encodes a counterclockwise rotation in degrees around the \(z\) axis of this coordinate system.
    If value 6 and 7 are not given, the resulting coordinate system is the recorders local coordinate system.
    \item 6: Float – \(x\)’ rotation. (Optional)\\
    If this value is given, values 5 and 7 are required.
    This value encodes a counterclockwise rotation in degrees around the \(x\) axis of the coordinate system rotated by value 5.
    \item 7: Float – \(z\)” rotation. (Optional)\\
    If this value is given, values 5 and 6 are required.
    This value encodes a counterclockwise rotation in degrees around the \(z\) axis of the coordinate system rotated by value 5 and 6.

    The resulting coordinate system is the recorders local coordinate system.
    \item 8: Float – The water depth. (Optional)\\
    This value holds the water depth from seafloor to the surface measured in meters.
    \item 9: string - Comment. (Optional)
  \end{itemize}

  \item 20: Integer – The sample rate divisor. (Required)\\
  This number scales the sample rate of every channel by a common divisor.
  The sample rate of every channel shall be divided by this value to get the actual sample rate.
  A value of zero or less is not allowed.

  \emph{Example:} If a channel with a rate of one sample per minute is needed, you can set this value to \(60\) and set the channel’s sample rate to \(1\).
  You can also, with the same results, set this value to \(6000\) and set the channel’s sample rate to \(100\).
  \item 21: Array – The channels. (Required)\\
  Each channel is encoded as table with the following keys:
  \begin{itemize}
    \item 1: String – The channel name. (Required)
    \item 2: String – The channel comment. (Optional)\\
    This might be a long name or instrument description.
    \item 3: Integer – The sample rate. (Required)
    When this field is divided by the sample rate divisor one gets the sample rate in Hz.
    The sample rate can not be zero.
    \item 4: Integer – The channel resolution. (Required)
    This field should be set to the maximum sample value, that the specific instrument can generate.
    This will be the value, to which the channel shall be normalised.
    For example, if the instrument’s ADC generates signed 16 bit samples, this value should be set to \(32\text{\,}768 = 2^{15}\).
    \item 5: Integer – LPC filter used for compression. (Required)\\
    Possible values are:
    \begin{quote}
      0 – No LPC filter is used.
      Samples are uncompressed apart from the variable length encoding.

      1 – Zero order hold.
      The sample values of this channel are encoded as \emph{differences} instead of \emph{absolute} values.

      2 – Linear continuation.
      Samples are predicted via linear continuation.
    \end{quote}
    See section \ref{compression} for more information on compression.
    \item 6: Float – The hardware gain of the preamplifier. (Optional)
    \item 7: Float – The software gain of the preamplifier. (Optional)
  \end{itemize}
  \item 22: Time – The start time. (Required)\\
  This TAIN label indicates, when the recording has been started.
  \item 23: Time – The stop time. (Required)\\
  This TAIN label indicates, when the recording has been stopped.
  \item 24: Array - The clock skew measurements. (Optional)\\
  Each clock skew measurement is encoded as a table with the following keys:
  \begin{itemize}
    \item 1: Time – The measurement time as taken by the internal clock. (Required)\\
    This is an absolute time.
    \item 2: Time – The measured skew. (Required)\\
    This is a duration.
    If this value is added to the measurement time, one gets the real time of the measurement.
    For example, if the internal clock has lost time, the skew will be positive.
  \end{itemize}
  \item 25: Integer – The number of samples. (Optional)\\
  This is the total number of samples in the file, i.\,e.\ of all channels added together.
\end{itemize}

\section{Data}


The data section contains both the samples and additional data of interest: the clock skew, time stamps and similar data.

The data is encoded as sequence of samples in their timely order, represented by a variable length integer. As described in section \ref{varint}, any byte within a “variable length integer” must not be higher than 191. Any byte that is higher than 191 starts with “11” and is used for non-sample data. The non-sample data can be embedded anywhere in the data stream between samples.

\newpage

\subsection{Sample Interleaving}

\begin{figure}[t]
\centerline{\begin{tikzpicture}
\draw[dotted, -latex] (-0.5, 0) node[left] {H} -- (7.5, 0);
\draw[dotted, -latex] (-0.5, -0.5) node[left] {X} -- (7.5,  -0.5);
\draw[dotted, -latex] (-0.5, -1) node[left] {Y} -- (7.5, -1);
\draw[dotted, -latex] (-0.5, -1.5) node[left] {Z} -- (7.5, -1.5);
\path[nodes={draw, circle, inner sep=2pt}]
  node (h0) at (0, 0) {}
  node (h1) at (1, 0) {}
  node (h2) at (2, 0) {}
  node (h3) at (3, 0) {}
  node (h4) at (4, 0) {}
  node (h5) at (5, 0) {}
  node (h6) at (6, 0) {}
  node (h7) at (7, 0) {}
  node (x0) at (0, -0.5) {}
  node (x1) at (3.5, -0.5) {}
  node (x2) at (7, -0.5) {}
  node (y0) at (0, -1) {}
  node (y1) at (3.5, -1) {}
  node (y2) at (7, -1) {}
  node (z0) at (0, -1.5) {}
  node (z1) at (3.5, -1.5) {}
  node (z2) at (7, -1.5) {};
\draw[-latex] (h0) -- (x0);
\draw[-latex] (x0) -- (y0);
\draw[-latex] (y0) -- (z0);
\draw[-latex] (z0) -- (h1);
\draw[-latex] (h1) -- (h2);
\draw[-latex] (h2) -- (h3);
\draw[-latex] (h3) -- (x1);
\draw[-latex] (x1) -- (y1);
\draw[-latex] (y1) -- (z1);
\draw[-latex] (z1) -- (h4);
\draw[-latex] (h4) -- (h5);
\draw[-latex] (h5) -- (h6);
\draw[-latex] (h7) -- (x2);
\draw[-latex] (x2) -- (y2);
\draw[-latex] (y2) -- (z2);
\draw[dashed]
  (-0.25, 0.25) rectangle (6.25, -1.75) node[below left] {1 Period}
  (7.5, 0.25) -- (6.75, 0.25) -- (6.75, -1.75) -- (7.5, -1.75);
\end{tikzpicture}}
\caption{Sample Interleaving. H: 210\,Hz, XYZ: 60\,Hz.}
\label{interleave-long}
\end{figure}

\begin{figure}[t]
\centerline{\begin{tikzpicture}
\draw[dotted, -latex] (-0.5, 0) node[left] {H} -- (7.5, 0);
\draw[dotted, -latex] (-0.5, -0.5) node[left] {X} -- (7.5,  -0.5);
\draw[dotted, -latex] (-0.5, -1) node[left] {Y} -- (7.5, -1);
\draw[dotted, -latex] (-0.5, -1.5) node[left] {Z} -- (7.5, -1.5);
\path[nodes={draw, circle, inner sep=2pt}]
  node (h0) at (0, 0) {}
  node (h1) at (1, 0) {}
  node (h2) at (2, 0) {}
  node (h3) at (3, 0) {}
  node (h4) at (4, 0) {}
  node (h5) at (5, 0) {}
  node (h6) at (6, 0) {}
  node (h7) at (7, 0) {}
  node (x0) at (0, -0.5) {}
  node (x1) at (3, -0.5) {}
  node (x2) at (6, -0.5) {}
  node (y0) at (0, -1) {}
  node (y1) at (3, -1) {}
  node (y2) at (6, -1) {}
  node (z0) at (0, -1.5) {}
  node (z1) at (3, -1.5) {}
  node (z2) at (6, -1.5) {};
\draw[-latex] (h0) -- (x0);
\draw[-latex] (x0) -- (y0);
\draw[-latex] (y0) -- (z0);
\draw[-latex] (z0) -- (h1);
\draw[-latex] (h1) -- (h2);
\draw[-latex] (h3) -- (x1);
\draw[-latex] (x1) -- (y1);
\draw[-latex] (y1) -- (z1);
\draw[-latex] (z1) -- (h4);
\draw[-latex] (h4) -- (h5);
\draw[-latex] (h6) -- (x2);
\draw[-latex] (x2) -- (y2);
\draw[-latex] (y2) -- (z2);
\draw[-latex] (z2) -- (h7);
\draw[dashed]
  (-0.25, 0.25) rectangle (2.25, -1.75) node[below left] {1 Period}
  (2.75, 0.25) rectangle (5.25, -1.75)
  (7.5, 0.25) -- (5.75, 0.25) -- (5.75, -1.75) -- (7.5, -1.75);
\end{tikzpicture}}
\caption{Sample Interleaving. H: 210\,Hz, XYZ: 70\,Hz.}
\label{interleave-short}
\end{figure}

To allow for different sample rates for the individual channels, the samples need to be interleaved.
This is done in a way, that permits small buffers, because samples can be written as soon as they are produced.

Samples which occur concurrently are written in order of their channels.
Samples which occur at different times are written in their timely order.

It is implicitly assumed, that the first sample of each channel is synchronized, i.\,e.\ they all occur at the same time.

If the least common multiple of the individual sample rates is kept as small as possible the interleaving periods will be kept short, which greatly improves performance (compare figure \ref{interleave-long} and \ref{interleave-short}).

\subsection{Control Frames}
\label{controlframes}

Aside from sample data, the data stream contains control frames, which carry additional information.
A control frame can be identified by it’s first byte which is always larger than \(191\).
It can appear anywhere in the data stream except in the middle of a multi byte sample or another control frame.

\begin{itemize}
  \item Time stamp <c0> – This value is followed by two variable length integers, which together form a TAIN label.
  This TAIN label encodes the absolute time of the next sample as measured by the internal clock.
  \item Lost sample <c1> – This value is a replacement for a lost or unknown sample.
  It replaces a sample value and counts towards the total number of samples in the file.
  Though, it is skipped by linear prediction, so the prediction for the next sample is made on the basis of it’s predecessors.
  \item Padding <c2> – This value can be used if the writing application wishes to pad the data.
  It is silently ignored.
  \item Annotation <c3> – This value is followed by a variable length integer and a string of bytes.
  The integer encodes the byte length of the string.
  The string is an arbitrary annotation that might be displayed in the waveform display of a viewing application.
  \item Sample number <c4> – This value is followed by a variable length integer.
  The integer encodes the number of the next sample.
  The number is counted over all channels, so there is no channel specific number.
  It is used to recover from lost passages of the file and to allow skipping to specific times.
  \item Summation constant <c5> – This value is followed by a variable length integer.
  The integer encodes what the last sample should have been.
  The state of the LPC filter is then reset to it’s start values.
  This value is used to recover from errors or missing passages in the file.
  It can also be used to allow skipping to specific times without reading the entire file.
  Note that this does not replace a sample.
  \item Estimated skew <c6> – This value is followed by two variable length integers, which together form a TAIN label.
  This TAIN label is a duration and encodes the estimated clock skew.
\end{itemize}

\subsection{Compression}
\label{compression}

The sample data may be compressed on a per channel basis using linear predictive coding.
This is controlled by the compression field of each channel.

Note, that all filters result in lossless compression.
All sample values are exactly reconstructed without any changes or loss of information.

The predictor is used to predict the next sample, so only the difference of the real sample value to the predicted value needs to be encoded.

Let \(x[n]\) be the \(n\)th sample and \(y[n]\) the \(n\)th prediction.
Then the \(n\)th difference is calculated as
\[
  d[n] = x[n] - y[n].
\]
There are multiple predictors to choose from.
This is indicated by the channel’s predictor number in the binary header.

0: No prediction is made, so it is always
\[
  y[n] = 0.
\]
This means, that all the samples are directly encoded in the stream.
This predictor is suitable for signals with small magnitude.
If the signal changes very slowly but has larger magnitudes, the zero order hold predictor might generate better results.

1: This is a simple zero order hold filter with
\[
  y[n] = x[n - 1].
\]

2: This is a linear continuation filter with
\[
  y[n] = 2x[n - 1] - x[n - 2].
\]

When the predictor is started or reset, previous samples will be assumed to be zero.

From time to time (e.\,g.\ once a second) the state of the predictor should be output in the data stream with control frame <c5>.
Every time the <c5> frame is output, the internal state of the predictor will be reset, i.\,e.\ all previous samples will be assumed to be zero.
This allows for recovery from lost or damaged passages and enabels skipping into the stream.

\section{Literature}

\begin{refliterature}
\item[Seed12] \textsc{Ahern, T. \& Dost, B.} \textit{Standard for the Exchange of Earthquake Data.} Incorporated Research Institutions for Seismology, 2012.
\item[Segy02] \textsc{Norris, M. \& Faichney, A.} \textit{SEG Y rev 1 Data Exchange format.} Society of Exploration Geophysicist, 2002.
\end{refliterature}

\end{document}
